use crate::CellVector;
///! Generic field-of-view algorithm.
use euclid::vec2;

/// User data for field of view cells.
pub trait FovValue: PartialEq + Clone {
    /// Construct a new FovValue for a position based on the previous one along the line of sight.
    fn advance(&self, offset: CellVector) -> Option<Self>;
}

/// Point in FOV arc polar coordinates for the desired geometry.
pub trait PolarPoint: Sized + Clone {
    /// Create the beginning and end points for radius 1 unit circle.
    ///
    /// These are the initial cells checked by the FOV algorithm.
    fn unit_circle_endpoints() -> (Self, Self);

    /// Return whether this point is earlier in the circle than the other.
    fn is_below(&self, other: &Self) -> bool;

    /// Return the vector offset for this point.
    fn to_v2(&self) -> CellVector;

    /// Return the point corresponding to this one on the next circle with +1 radius.
    fn expand(&self) -> Self;

    /// Step forward on the current radius.
    fn advance(&mut self);
}

/// Field of view iterator.
pub struct Fov<P, T> {
    stack: Vec<Arc<P, T>>,
    /// Extra values generated by special cases.
    side_channel: Vec<(CellVector, T)>,
}

impl<P: PolarPoint, T: FovValue> Fov<P, T> {
    /// Create a new field of view iterator with a seed userdata for the origin position.
    pub fn new(init: T) -> Fov<P, T> {
        // We could run f for (0, 0) here, but the traditional way for the FOV to work is to only
        // consider your surroundings, not the origin site itself.
        Fov {
            stack: vec![Arc::new(init.clone())],
            // The FOV algorithm will not generate the origin point, so we use
            // the side channel to explicitly add it in the beginning.
            side_channel: vec![(vec2(0, 0), init)],
        }
    }
}

impl<P: PolarPoint, T: FovValue> Iterator for Fov<P, T> {
    type Item = (CellVector, T);
    fn next(&mut self) -> Option<(CellVector, T)> {
        // Empty the side channel before proceeding to the algorithm proper.
        if let Some(ret) = self.side_channel.pop() {
            return Some(ret);
        }

        // Start processing the next arc in the stack.
        if let Some(current) = self.stack.pop() {
            if current.arc_has_split(&mut self.stack) {
                return self.next();
            }

            debug_assert!(current.group_value == current.prev_value.advance(current.pt.to_v2()));

            let pos = current.pt.to_v2();
            let ret = current.group_value.clone();

            current.advance(&mut self.stack);

            if let Some(ret) = ret {
                return Some((pos, ret));
            } else {
                return self.next();
            }
        } else {
            None
        }
    }
}

struct Arc<P, T> {
    /// Start point of current arc.
    begin: P,
    /// Point currently being processed.
    pt: P,
    /// End point of current arc.
    end: P,
    /// The user value from previous iteration.
    prev_value: T,
    /// The user value for this group.
    group_value: Option<T>,
}

impl<P: PolarPoint, T: FovValue> Arc<P, T> {
    pub fn new(init: T) -> Arc<P, T> {
        let (begin, end) = P::unit_circle_endpoints();
        Self::expand(begin, end, init)
    }

    fn expand(begin: P, end: P, prev_value: T) -> Arc<P, T> {
        let group_value = prev_value.advance(begin.to_v2());
        Arc {
            begin: begin.clone(),
            pt: begin,
            end,
            prev_value,
            group_value,
        }
    }

    /// Consume the given arc and add its descendent, if any, to the stack.
    pub fn advance(mut self, stack: &mut Vec<Arc<P, T>>) {
        self.pt.advance();
        if self.pt.is_below(&self.end) {
            stack.push(self);
        } else if let Some(group_value) = self.group_value {
            stack.push(Arc::expand(
                self.begin.expand(),
                self.end.expand(),
                group_value,
            ));
        }
    }

    /// If the arc has advanced into a different value group, split it into the given stack.
    ///
    /// Return true if arc was split, false otherwise.
    pub fn arc_has_split(&self, stack: &mut Vec<Arc<P, T>>) -> bool {
        let next_value = self.prev_value.advance(self.pt.to_v2());
        if next_value != self.group_value {
            // Using the literal instead of the constructor to avoid recomputing next_value.
            stack.push(Arc {
                begin: self.pt.clone(),
                pt: self.pt.clone(),
                end: self.end.clone(),
                prev_value: self.prev_value.clone(),
                group_value: next_value,
            });

            // Extend current arc if it has a group value.
            if let Some(ref group_value) = self.group_value {
                stack.push(Arc::expand(
                    self.begin.expand(),
                    self.pt.expand(),
                    group_value.clone(),
                ));
            }

            true
        } else {
            false
        }
    }
}
